import * as fs from 'fs-extra'
import { join, dirname } from 'path'
import execa, { Options as ExecaOptions } from 'execa'

import { log } from './logger'
import { MrapiOptions, DBProvider } from '../types'
import { requireFromProject, getNodeModules } from './tools'

const PRISMA_CLIENT = '.prisma/client'

export const checkPrismaClient = () => {
  // from prisma-beta.4, Prisma Client is now generated into a folder called node_modules/.prisma
  // https://github.com/prisma/prisma/releases/tag/2.0.0-beta.4
  try {
    const client = requireFromProject(PRISMA_CLIENT)
    return client && !!client.dmmf ? client : false
  } catch (err) {
    return false
  }
}

export const checkPrismaSchema = (database: any, cwd = process.cwd()) => {
  const schemaFilePath = join(
    cwd,
    database?.schemaOutput || 'prisma/schema.prisma',
  )
  return fs.pathExists(schemaFilePath)
}

export const initPrisma = async (
  options: MrapiOptions,
  cwd = process.cwd(),
) => {
  if (!(await checkPrismaSchema(options.database, cwd))) {
    await generate(options, cwd)
    await migrate.save(options, cwd, '')
    await migrate.up(options, cwd, '')
  }
  if (!(await checkPrismaClient())) {
    await migrate.save(options, cwd, '')
    await migrate.up(options, cwd, '')
  }
}

export const getModels = async (userConfig?: Record<string, string[]>) => {
  const client = checkPrismaClient()
  const dmmf = client ? client.dmmf : null
  if (!dmmf) {
    return null
  }
  let models = JSON.parse(JSON.stringify(dmmf.datamodel.models))
  const mappings = JSON.parse(JSON.stringify(dmmf.mappings))
  models = models
    .map((model: any) => {
      const mapping = mappings.find((m: any) => m.model === model.name)
      if (mapping) {
        return {
          ...model,
          api: mapping.plural,
          methods: Object.keys(mapping)
            .map((key) => (['model', 'plural'].includes(key) ? null : key))
            .filter(Boolean),
        }
      }
      return null
    })
    .filter(Boolean)

  if (!userConfig) {
    return models
  }

  let modelsCopy = []
  for (let name of Object.keys(userConfig)) {
    const model = models.find((m: any) => m.name === name)
    if (!model) {
      log.warn(`model '${name}' not found`)
      continue
    }

    let methods = userConfig[name]
    if (!Array.isArray(methods)) {
      log.warn(`methods should be array, get '${methods}'`)
      continue
    }

    const tmp = JSON.parse(JSON.stringify(model))
    tmp.methods = methods.filter((m) => {
      if (!model.methods.includes(m)) {
        log.warn(`method '${name}.${m}' not found`)
        return false
      }
      return true
    })

    modelsCopy.push(tmp)
  }

  return modelsCopy
}

export const runPrisma = async (cmd: string, options?: ExecaOptions) => {
  const cmdStr =
    'npx prisma ' +
    (cmd.includes('migrate') || cmd.includes('studio')
      ? cmd + ' --experimental'
      : cmd)

  log.debug(`[EXEC] ${cmdStr}...`)
  await execa.command(cmdStr, {
    stdout: 'inherit',
    stdin: 'inherit',
    ...options,
  })
  log.debug(`[DONE] ${cmdStr}`)
}

export const runPMT = async (cmd: string, options?: ExecaOptions) => {
  const cmdStr = `npx prisma-multi-tenant ${cmd}`

  log.debug(`[EXEC] ${cmdStr}...`)
  await execa.command(cmdStr, {
    stdin: 'inherit',
    stdout: 'inherit',
    cwd: process.cwd(),
    ...options,
  })
  log.debug(`[DONE] ${cmdStr}`)
}

export const create = async (
  { database, plugins }: MrapiOptions,
  cwd = process.cwd(),
) => {
  if (!database || !database.schema) {
    throw new Error('database.schema is required')
  }
  if (!plugins) {
    throw new Error('plugins is required')
  }
  log.debug('creating schema.prisma...')
  const isMultiTenant = !!database.multiTenant
  const prismaFilePath = join(cwd, database.schema)
  const userSchemaContent = await fs.readFile(prismaFilePath, 'utf8')
  const info = isMultiTenant
    ? getUrlAndProvider(database.multiTenant.tenants[0].url)
    : getUrlAndProvider(database.url)

  const typegraphqlPrismaPath = `node ${join(
    getNodeModules(),
    'typegraphql-prisma/lib/cli/generator.js',
  )}`
  const TYPE_GRAPHQL_PROVIDER = typegraphqlPrismaPath
  const TYPE_GRAPHQL_OUTPUT =
    plugins['builtIn:graphql']?.options?.buildSchema?.resolvers?.generated ||
    '../src/generated'
  const baseSchemaContent = await fs.readFile(
    join(__dirname, '../../resource/schema.prisma'),
    'utf8',
  )

  // schema.prisma
  const schema =
    '// Generated by mrapi. DO NOT modify it manually.\n' +
    baseSchemaContent.replace('$DB_PROVIDER$', info.provider) +
    '\n' +
    userSchemaContent
  const schemaOutput = join(cwd, database.schemaOutput)
  await fs.outputFile(schemaOutput, schema)
  log.debug('schema.prisma created')

  // .env file
  const envPath = join(dirname(database.schemaOutput), '.env')
  let envContent = `# Generated by mrapi. DO NOT modify it manually.
DATABASE_URL="${info.url}"
TYPE_GRAPHQL_PROVIDER="${TYPE_GRAPHQL_PROVIDER}"
TYPE_GRAPHQL_OUTPUT="${TYPE_GRAPHQL_OUTPUT}"
`
  if (isMultiTenant) {
    const managementInfo = getUrlAndProvider(
      database.multiTenant.management.url,
    )
    envContent += `
# The following env variables are used by prisma-multi-tenant
MANAGEMENT_PROVIDER="${managementInfo.provider}"
MANAGEMENT_URL="${managementInfo.url}"
      `
  }
  await fs.outputFile(envPath, envContent)
}

export const generate = async (options: MrapiOptions, cwd = process.cwd()) => {
  await create(options, cwd)

  const envPath = join(dirname(options.database.schemaOutput), '.env')
  require('dotenv').config({
    path: envPath,
  })
  try {
    const isMultiTenant = !!options.database.multiTenant
    if (isMultiTenant) {
      await runPMT('generate')
      log.debug('prisma multiple tenants generated')
    } else {
      await runPrisma('generate')
      log.debug('prisma client generated')
    }
  } catch (err) {
    if (!err.message.includes('defined any model in your schema.prisma')) {
      throw err
    }
  }
  process.exit(0)
}

export const migrate = {
  save: async (
    options: MrapiOptions,
    cwd = process.cwd(),
    name = '',
    config = {},
  ) => {
    if (!(await checkPrismaSchema(options, cwd))) {
      await create(options, cwd)
    }

    const isMultiTenant = !!options.database.multiTenant
    if (isMultiTenant) {
      await runPMT(name ? `migrate ${name} save` : 'migrate save')
    } else {
      await runPrisma('migrate save')
    }
  },
  up: async (
    options: MrapiOptions,
    cwd = process.cwd(),
    name = '',
    config = {},
  ) => {
    if (!(await checkPrismaSchema(options.database, cwd))) {
      await create(options, cwd)
    }

    const isMultiTenant = !!options.database.multiTenant
    if (isMultiTenant) {
      await runPMT(`migrate management up`)
      await runPMT(name ? `migrate ${name} up` : 'migrate up')
    } else {
      await runPrisma('migrate up')
    }
  },
  down: async (
    options: MrapiOptions,
    cwd = process.cwd(),
    name = '',
    config = {},
  ) => {
    if (!(await checkPrismaSchema(options.database, cwd))) {
      await create(options, cwd)
    }

    const isMultiTenant = !!options.database.multiTenant
    if (isMultiTenant) {
      await runPMT(name ? `migrate ${name} down` : 'migrate down')
    } else {
      await runPrisma('migrate down')
    }
  },
}

export const studio = async (
  options: MrapiOptions,
  cwd = process.cwd(),
  name = '',
  config = {},
) => {
  const isMultiTenant = !!options.database.multiTenant
  if (isMultiTenant) {
    await runPMT(`studio ${name}`)
  } else {
    await runPrisma('studio')
  }
}

export const introspect = async (
  options: MrapiOptions,
  cwd = process.cwd(),
  name = '',
  config = {},
) => {
  if (!(await checkPrismaSchema(options.database, cwd))) {
    await create(options, cwd)
  }
  await runPrisma('introspect')
}

export const getUrlAndProvider = (url: string) => {
  const _url = url.trim()
  if (!_url) {
    throw new Error(`database url can not be empty`)
  }
  const str = _url.split(':')[0]
  if (!str) {
    throw new Error(
      `unable to detect database database provider, received empty '${str}'`,
    )
  }

  let provider = ''
  switch (str) {
    case DBProvider.mysql:
      provider = DBProvider.mysql
      break
    case DBProvider.postgresql:
      provider = DBProvider.postgresql
      break
    case 'file':
      provider = DBProvider.sqlite
      break
    default:
      throw new Error(
        `Unrecognized '${str}' provider. Known providers: ${DBProvider.mysql}, ${DBProvider.postgresql}, ${DBProvider.sqlite}`,
      )
  }

  return {
    url: _url,
    provider,
  }
}
