# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateRole {
  count(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: RoleWhereUniqueInput, before: RoleWhereUniqueInput, first: Int, last: Int): Int!
}

type AggregateUser {
  count(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): Int!
}

type BatchPayload {
  count: Int!
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  not: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
}

type Mutation {
  createOneRole(data: RoleCreateInput!): Role!
  deleteOneRole(where: RoleWhereUniqueInput!): Role
  updateOneRole(data: RoleUpdateInput!, where: RoleWhereUniqueInput!): Role
  deleteManyRole(where: RoleWhereInput): BatchPayload!
  updateManyRole(data: RoleUpdateManyMutationInput!, where: RoleWhereInput): BatchPayload!
  upsertOneRole(where: RoleWhereUniqueInput!, create: RoleCreateInput!, update: RoleUpdateInput!): Role!
  createOneUser(data: UserCreateInput!): User!
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  deleteManyUser(where: UserWhereInput): BatchPayload!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertOneUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
}

input NullableStringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}

enum OrderByArg {
  asc
  desc
}

type Query {
  role(where: RoleWhereUniqueInput!): Role
  roles(where: RoleWhereInput, orderBy: RoleOrderByInput, skip: Int, after: RoleWhereUniqueInput, before: RoleWhereUniqueInput, first: Int, last: Int): [Role!]!
  aggregateRole: AggregateRole!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  aggregateUser: AggregateUser!
}

type Role {
  id: String!
  name: String!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]
}

input RoleCreateInput {
  id: String
  name: String!
  users: UserCreateManyWithoutRoleInput
}

input RoleCreateOneWithoutUsersInput {
  create: RoleCreateWithoutUsersInput
  connect: RoleWhereUniqueInput
}

input RoleCreateWithoutUsersInput {
  id: String
  name: String!
}

input RoleOrderByInput {
  id: OrderByArg
  name: OrderByArg
}

input RoleUpdateInput {
  id: String
  name: String
  users: UserUpdateManyWithoutRoleInput
}

input RoleUpdateManyMutationInput {
  id: String
  name: String
}

input RoleUpdateOneWithoutUsersInput {
  create: RoleCreateWithoutUsersInput
  connect: RoleWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: RoleUpdateWithoutUsersDataInput
  upsert: RoleUpsertWithoutUsersInput
}

input RoleUpdateWithoutUsersDataInput {
  id: String
  name: String
}

input RoleUpsertWithoutUsersInput {
  update: RoleUpdateWithoutUsersDataInput!
  create: RoleCreateWithoutUsersInput!
}

input RoleWhereInput {
  id: StringFilter
  name: StringFilter
  users: UserFilter
  AND: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
}

input RoleWhereUniqueInput {
  id: String
  name: String
}

input StringFilter {
  equals: String
  not: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
}

type User {
  id: String!
  name: String!
  email: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  roleId: String
  role: Role
}

input UserCreateInput {
  id: String
  name: String!
  email: String
  password: String!
  createdAt: DateTime
  updatedAt: DateTime
  role: RoleCreateOneWithoutUsersInput
}

input UserCreateManyWithoutRoleInput {
  create: [UserCreateWithoutRoleInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutRoleInput {
  id: String
  name: String!
  email: String
  password: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input UserFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input UserOrderByInput {
  id: OrderByArg
  name: OrderByArg
  email: OrderByArg
  password: OrderByArg
  createdAt: OrderByArg
  updatedAt: OrderByArg
  roleId: OrderByArg
}

input UserScalarWhereInput {
  id: StringFilter
  name: StringFilter
  email: StringFilter
  password: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  roleId: NullableStringFilter
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

input UserUpdateInput {
  id: String
  name: String
  email: String
  password: String
  createdAt: DateTime
  updatedAt: DateTime
  role: RoleUpdateOneWithoutUsersInput
}

input UserUpdateManyDataInput {
  id: String
  name: String
  email: String
  password: String
  createdAt: DateTime
  updatedAt: DateTime
}

input UserUpdateManyMutationInput {
  id: String
  name: String
  email: String
  password: String
  createdAt: DateTime
  updatedAt: DateTime
}

input UserUpdateManyWithoutRoleInput {
  create: [UserCreateWithoutRoleInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  delete: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutRoleInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  deleteMany: [UserScalarWhereInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutRoleInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutRoleDataInput {
  id: String
  name: String
  email: String
  password: String
  createdAt: DateTime
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutRoleInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutRoleDataInput!
}

input UserUpsertWithWhereUniqueWithoutRoleInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutRoleDataInput!
  create: UserCreateWithoutRoleInput!
}

input UserWhereInput {
  id: StringFilter
  name: StringFilter
  email: StringFilter
  password: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  roleId: NullableStringFilter
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  role: RoleWhereInput
}

input UserWhereUniqueInput {
  id: String
  name: String
}
